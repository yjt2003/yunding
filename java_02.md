### 2.java进阶part2
#### 目录：
* [方法](#jump1)
* [面向对象](#jump2)
* [java内存分配](#jump3)
* [基本，引用数据类型](#jump4)
* [成员，局部变量](#jump5)
* [字符串](#jump6)
* [继承](#jump7)
* [static,final,super](#jump8)
* [抽象类](#jump9)
* [接口](#jump10)
* [块作用域](#jump11)

* #### 方法<a id = "jump1">:</a>
  * 定义与调用：`public static void 名称(){语句体}`  调用： `名称(参数一，参数二)`
  * 传参：`public static void 名称(int num1，int num2){语句体}`   **传参保持数据的个数与类型一致**
  * 返回值：return 返回值;
  * 方法重载：处于同一类下，方法名称一样，形式参数不一样的两种方法（**一般来说会把相同功能的方法名起成一样的**）
  * ==底层原理==：
    * 方法在运行时进入栈内存运行，运行完毕就==出栈==（**变量有作用域的原理**）。***先进后出***
    * ==new==出来的都在堆内存空间中开辟空间。
    * 数据类型：
      * 引用数据类型：变量里面存储的是存储数据的地址。**储存在堆内存当中（数组，但数组名存储在栈内存中）。**
      * 基本数据类型：变量里面存储的是数据。**储存在栈内存当中。**
* #### 面向对象<a id = "jump2">:</a>
  * 定义类：
    * `public class 类名{}`  定义类（==这样定义类必须在**类名.class**文件下；如果不想，去掉public即可==）
    * `string band;double price`  大括号内可以放属性(成员变量)
    * `public void 方法名(){}`  大括号里面可以放行为(成员方法)
    ###### 看idea 相关的代码 
    ==注意：==
    * 一个代码文件中只能有一个类是public修饰的。
    * public修饰的类名必须是java代码的文件名称
  * 封装：
    * 对象代表什么就得封装对应的数据，提供数据对应的行为。
    * 对应于sun公司开发的各种各样的封装包。 
  * private关键字：
    * 在类当中向属性与数据前面加private(public)关键字，将成员对象由公有变成私有(私有变成公有)。==public一般用于修饰类当中的方法==
    * **与python一样，调用私有成员变量需要使用类里面的相关方法**
    ==按照习惯来说，针对于每一个私有化成员变量，我们都要创建一个对应的get set方法==
  * ***this关键字:***
    * 区分成员变量和局部变量
    * 在函数名前面加上this关键字使得在**局部变量与全局变量同名时**想要避免==就近原则==而**访问全局变量**可以实现。
    * ==内存原理==：本质为方法调用者的**地址值**,虚拟机自动进行赋值。
    * ==访问本类的构造方法==：直接加`this()`和`super()`一样，其作用会直接调用另外一个同类的构造方法，而本类中就不会有super()方法了。
  * 构造方法:（作用就是创建对象的时候给成员对象初始化的）
    * 写在类内，分为空参构造，有参构造。
    * ==方法名与类名相同==，大小写一致。
    * 没有返回值类型
    * 没有具体的返回值
    * 创建对象时由虚拟机*自动调用*不能手动调用构造方法---***每创建一次对象就会调用一次构造方法。***
    * `public 类名(可传参数){函数体}`
* #### java内存分配介绍<a id = "jump3">:</a>
    * 栈 
       * 方法运行时所进入的内存
       * 变量所存储的空间（==创建对象过程中：代码`Student p = new Student()；`==当中p变量==储存的是堆内存赋予==的地址值，所以是`p.name`来调用类当中的属性）。         ==***p在这里相当于指向堆空间（类）的指针***==
       * new 出来的两个空间互相独立。
    * 堆
       * 只要是==new==出来的东西会在这块内存中开辟空间。
       * 开辟空间的都会分配一个地址值。==创建对象最后一步需要将这个空间的地址值赋值给栈里面的变量== 
       * 例如创建对象时，new类当中的成员变量的初始值以及成员方法的地址(成员方法储存在方法区)
       * ###### 强调一下：数组的实际存储空间也是在堆内存中存储的（然后将数组的首地址传给栈内的变量（即数组名））。
     <img src="https://200307yjt.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20193933.png">
     
    * 方法区
       * ==运行一个类==的时候，这个类的字节码文件就会加载到方法区中**临时存储**。里面会有所有**成员变量的临时存储**，还会有**所有成员方法的临时存储**。
    * 本地方发栈
    * 寄存器
    * <a id = "jump">String Table串池:</a>
        * 在**堆内存**当中存储，只有==通过直接赋值的方式创建的字符串才可以存在里面==。
        * 同时，系统会检查该字符串在串池中是否存在（char的引用），存在即复用（*节约内存*）（*直接赋值地址值*），不存在再在堆中创建新的。
    * **java的对齐填充机制**：在java内存中一般会将对象存储的字节数按照8字节整数倍自动补齐，这是因为CPU在读取数据时一次性可以读取8字节，这样的机制大大加强了内存读取效率，同时也将碎片化的内存化整。
* #### 基本数据类型和引用数据类型<a id = "jump4">:</a>
    * 基本数据类型：数据值存在自己空间里面。赋值时直接传值。
    * 引用数据类型：数据存在其他空间里面，自己空间中存储地址值。
* #### 成员变量，局部变量<a id = "jump5">:</a>
    * <img src="https://200307yjt.oss-cn-beijing.aliyuncs.com/%E4%BA%91%E9%A1%B6%E7%AC%94%E8%AE%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20211321.png">
* #### 字符串<a id = "jump6">:</a>
    * 概述：
      * String是java定义好的一个类，使用时不需要导包。
      * java中的所有字符串文字都被实例化为此类的对象。
      * 字符串的值一旦创建之后不能被改变，***字符串内部的存储空间是不能改变（或删除）的***。
      * 内存：[String Table串池](#jump):
      * 多种创建字符串的方法：
      <img src="https://200307yjt.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20191719.png">
      * 字符串中的常见方法：
        * 字符串中的比较：
        <img src="https://200307yjt.oss-cn-beijing.aliyuncs.com/%E4%BA%91%E9%A1%B6%E7%AC%94%E8%AE%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-28%20113014.png">
* #### 继承<a id = "jump7">:</a>
    * ==Object类==：每一个类都直接或间接的继承于Object类。如果一个类没有写继承关系，虚拟机自动添加一个父类Object
    * java不允许多继承，只支持单继承。一个子类只能继承一个父类。但是可以多层继承（间接父类）。
    * 子类只能访问父类中非私有的成员。
    *  `public class son extends father ()`
    *  <mark>构造方法不能被子类继承</mark>但虚拟机可以自动添加一个空参构造。
    *  内存结构:
        *  在对一个继承了对应父类的子类使用new关键字创建对象时，在堆内存里面会将空间分成**两部分**空间创立：一部分为其继承的父类，另一部分为其自身。（仍然共用同一个地址值）。==（在调用父类的成员方法时，jvm虚拟机会生成一张虚方法表从而方便子类调用父类的方法==
        <img src="https://200307yjt.oss-cn-beijing.aliyuncs.com/%E4%BA%91%E9%A1%B6%E7%AC%94%E8%AE%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20165242.png">
        ==只有父类中的虚方法才能被子类继承==
        *  在调用堆内存中的成员变量时，先在子类里面找，找不到再找父类里面找。
        *  在方法区加载字节码文件时他会把父类也加载进来。相当于每一个方法区内都有一个Object类。
    * 在java虚拟机当中存在一种特殊且自动的**垃圾回收机制**，可以将堆中已经废弃的内存空间回收
    * **关于成员变量**：在java里面都可以继承下来，只不过经过private关键字修饰过的成员变量需要通过get，set方法访问。
* #### Static，Final，Super()<a id = "jump8">:</a>
    * **static**:被所有实例所==共享==，用类名调用。
      * 内存结构：在堆空间里面，会生成一个单独存放该类所有的静态变量的**静态区**。静态变量随着类的加载而加载，优先于对象的出现在内存里面。
      * 静态方法没有this
      * 静态方法无法调用非静态的成员或方法，（内存当中保存的地方不一样）；非静态的实例可以访问静态的变量（共享）
      * 静态方法无法调用实例变量
      * 静态方法可以被继承，不能被重写
    * 工具类：私有化构造方法，外界不可以创建对象（没有意义）。
    * **super**----代表父类的存储空间:
      * 在子类中会默认的**访问父类中的无参构造**后在执行自己（==子类不会继承父类中的构造方法==）。------------>**子类构造方法第一句默认都是super()，不写也存在（虚拟机自动添加），必须只在第一行**。
      * 若想调用有参构造必须手动写super()进行调用。---------------->由参数的个数和类型决定
      * 调用父类的构造方法完成父类数据空间初始化。
  <img src="https://200307yjt.oss-cn-beijing.aliyuncs.com/%E4%BA%91%E9%A1%B6%E7%AC%94%E8%AE%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-28%20104751.png">
    * **final**:(最终的修饰：方法，类，变量)
      * 修饰方法时：方法为最终方法不可被重写。**不可被改变的方法**。
      * 修饰类：表示类是最终类，不能被继承。
      * 修饰变量:只能被赋值一次。(常量)。
* #### 抽象类（父类的一种 形式）<a id = "jump9">:</a>
    * 抽象方法：方法抽取后由于不能确定子类对该方法的执行内容。==无方法体==**故在父类中不能确定具体的方法体**
     ==一个类中存在抽象方法，必须声明为抽象类，该类不能创建对象==
    * **1.可以有构造方法。2.抽象类的子类要么是抽象类要么重写抽象类中所有抽象方法。**
    *****
* #### 接口(一种方法，行为的规则)<a id = "jump10">:</a>
    * 一个类可以实现多个接口，逗号链接
    * 接口被实现了以后，重写接口中的所有抽象方法。
* #### 块作用域<a id = "jump11">:</a>
  ```java
  /*
   * 块block: {}->作用域
   * 	{}定义在方法中->局部代码块|普通语句块				执行时机:调用方法
   *  {}定义在类中方法外->构造块						执行时机:new
    *  static{}定义在类中方法外->静态块				执行时机:在类第一次加载以后执行一次
   *  同步块
   *  
   *  构造块先于构造器的代码执行,如果存在多个构造块,从上到下以此执行
   *  静态块先于主方法执行,如果存在多个静态块,从上到下依次执行
   *  
   *  static->main->构造块->构造器
  */
  public class BlockDemo01 {
	//如果存在静态块,静态变量,从上到下依次执行
	static int a=10;
	static{
		System.out.println(a);
	}
	
	int b=5;
	
	static{
		System.out.println("我是静态块1"+a);
		//BlockDemo01 bd=new BlockDemo01();
		//System.out.println(bd.b);
	}
	
	static{
		System.out.println("我是静态块2");
	}
	
	public BlockDemo01() {
		System.out.println("我是构造器");
	}
	
	//构造块
	{
		System.out.println("我是构造块1");
		System.out.println(a);
		System.out.println(b);
	}
	{
		System.out.println("我是构造块2");
	}
	{
		System.out.println("我是构造块3");
	}

	public static void main(String[] args) {
		System.out.println("main");
		int a=15; //作用域在变量声明开始,到离我最近的,包裹你的{}的}为止
				  //同一个作用域之内变量不能重名,使用就近原则使用
		//局部代码块
		
		{
			int b=5;  //作用域就在代码块中
			System.out.println(a);
		}
		System.out.println("-------"+BlockDemo01.a);
		
		BlockDemo01 bd=new BlockDemo01();
		System.out.println(bd.a);
		
		//System.out.println(b);  无法使用
	}	
  }
  ```
  #### 数据类型装箱拆箱
  ```java
  float f = 66.6f;
  Float f1 = new Float(f);//手动装箱
  Float f2 = f//自动装箱
  Double d = new Double(88.88);//double类内创建实例且赋值
  double d1 = d.doubleValue();//手动拆箱
  int i1 = d.doubleValue();//将double类型强制转换成int类型
  double d2 = d;//自动拆箱

  //字符串的转换比较特殊：
  //将基本类型转化为字符串：
  int c = 10;
  String str = String.valueOf(c);
  String str = c + "";
  //字符串转化为基本类型：
  String str = "8";
  int d = Integer.valueOf(str);
  ```